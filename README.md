1. spawner.spawn(...) mengirimkan task asynchronous ke channel milik executor. Ini adalah operasi yang tidak memblokir (non-blocking). Baris println!("Fayyed: hey hey"); dieksekusi secara sinkron di thread utama segera setelah task di-spawn. executor.run() kemudian mulai memproses task dari antriannya. Task pertama yang diambil akan mulai dieksekusi (async blok), mencetak "Fayyed: howdy!", lalu await TimerFuture. Saat TimerFuture di-await dan mengembalikan Poll::Pending, executor akan menangguhkan task tersebut dan bisa mengerjakan task lain jika ada. Dalam kasus ini, karena TimerFuture menggunakan thread::sleep di thread terpisah, thread utama (yang menjalankan executor) tidak diblokir oleh sleep tersebut. Waker akan dipanggil oleh thread timer setelah 2 detik, yang menyebabkan task dijadwalkan ulang dan akhirnya mencetak "Fayyed: done!".

2. Multiple Spawn: Executor akan menangani beberapa future secara bersamaan (konkuren). Setiap spawn menambahkan task ke antrian. Executor mem-poll mereka. Karena TimerFuture kita bersifat "non-blocking" terhadap executor (ia menggunakan thread terpisah untuk sleep), executor dapat beralih antar task yang menunggu. Urutan "done" akan tergantung pada durasi masing-masing timer. Efek drop(spawner): drop(spawner) menyebabkan SyncSender (yaitu task_sender) di dalam Spawner di-drop. Ketika semua SyncSender untuk sebuah sync_channel telah di-drop, panggilan berikutnya ke recv() pada Receiver yang terkait akan mengembalikan Err. Ini memberi sinyal kepada loop while let Ok(...) di executor.run() untuk berhenti, sehingga program bisa keluar dengan bersih. Jika spawner (atau klonnya) tidak di-drop, Receiver akan terus menunggu (blocking) di recv(), mengasumsikan lebih banyak task mungkin datang.